M <- 1000
x <- runif(M)
t <- rgeom(M, x)
hist(t)
hist(t, breaks = 100)
hist(t, breaks = 100, xlim=c(0,10))
hist(t, breaks = 1000, xlim=c(0,10))
hist(t, breaks = 2000, xlim=c(0,10))
curve(dgeom(x))
curve(1/(x*(1+x)), add = T, col='red', lwd = 3)
hist(t, breaks = 2000, xlim=c(0,10), freq = F)
curve(1/(x*(1+x)), add = T, col='red', lwd = 3)
box()
grid()
hist(t, breaks = 2000, xlim=c(0,10), freq = F)
curve(1/(x*(1+x)), add = T, col='red', lwd = 3)
box()
rm(list=ls())       #Clear output
library(VGAM)
# Exercise_2
set.seed(13112221)  # For reprocibility
##### Step Function for p_hat #####
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat){
interval <- cut(x, bins, include.lowest = T)
return(p_hat[interval])
}
##### Step Function for q_hat #######
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
return(q_hat[interval])
}
##### Mixture distribution of Beta ######
dmixture <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
##### Random sample from Mixture Beta  #####
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
#####  Simulation Function #######
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
print(m)
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = dmixture
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'!")}
matr <- matrix(NA , )
matr_integral <- matrix(NA , nrow = sim_size  , ncol = 3)
for(rep in 1:sim_size){
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the integral
p <- integrate(function(x) ( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat))^2 , lower = 0 , upper = 1, subdivisions = 1200)$value
q <- integrate(function(x) (( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2), lower = 0 , upper = 1, subdivisions = 1200)$value
pq <- integrate(function(x) (( p_hat_func(x,bins = bins , p_hat = p_hat ) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2), lower = 0 , upper = 1, subdivisions = 1200)$value
matr_integral[rep,1] <- p
matr_integral[rep,2] <- q
matr_integral[rep,3] <- pq
}
mise_p <- mean(integral_p[,1])   #Save the results
mise_q <- mean(integral_q[,2])   #Save the results
mise_pq <- mean(integral_pq[,3])
return(c(mise_p , mise_q, mise_pq))
}
##### Running Simulation  #####
m <- seq(5,50, 1)
simulation_size <- 100
labels <- c("p_hat" , "q_hat", 'pq')
#######Beta
### 1
Mixture_sim_n100_eps_01 <- lapply(m, simulation_function, sim_size = simulation_size, n=100 , func='mixture', eps = .1)
rm(list=ls())       #Clear output
library(VGAM)
# Exercise_2
set.seed(13112221)  # For reprocibility
##### Step Function for p_hat #####
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat){
interval <- cut(x, bins, include.lowest = T)
return(p_hat[interval])
}
##### Step Function for q_hat #######
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
return(q_hat[interval])
}
##### Mixture distribution of Beta ######
dmixture <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
##### Random sample from Mixture Beta  #####
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
#####  Simulation Function #######
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
print(m)
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = dmixture
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'!")}
matr <- matrix(NA , )
matr_integral <- matrix(NA , nrow = sim_size  , ncol = 3)
for(rep in 1:sim_size){
X <- sample_distr(n)   # Generating the random sample from the beta
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(X, bins, include.lowest = T)  # Rename units with the bins they belong
pj_hat <- table(intervals) / n              # Finding the frequencies of units inside each bins
p_hat <- as.vector(pj_hat / h)              # Computing high of each bin dividing the frequencies for the width of the bin
nu <- rlaplace(m, 0, 2/eps)                 # Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + nu                 # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
# Compute the integral
p <- integrate(function(x) ( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat))^2 , lower = 0 , upper = 1, subdivisions = 1200)$value
q <- integrate(function(x) (( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2), lower = 0 , upper = 1, subdivisions = 1200)$value
pq <- integrate(function(x) (( p_hat_func(x,bins = bins , p_hat = p_hat ) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2), lower = 0 , upper = 1, subdivisions = 1200)$value
matr_integral[rep,1] <- p
matr_integral[rep,2] <- q
matr_integral[rep,3] <- pq
}
mise_p <- mean(matr_integral[,1])   #Save the results
mise_q <- mean(matr_integral[,2])   #Save the results
mise_pq <- mean(matr_integral[,3])
return(c(mise_p , mise_q, mise_pq))
}
##### Running Simulation  #####
m <- seq(5,50, 1)
simulation_size <- 100
labels <- c("p_hat" , "q_hat", 'pq')
#######Beta
### 1
Mixture_sim_n100_eps_01 <- lapply(m, simulation_function, sim_size = simulation_size, n=100 , func='mixture', eps = .1)
rm(list=ls())       #Clear output
library(VGAM)
# Exercise_2
set.seed(13112221)  # For reprocibility
##### Step Function for p_hat #####
# Defining step functions for p_hat
p_hat_func <- function(x , bins , p_hat){
interval <- cut(x, bins, include.lowest = T)
return(p_hat[interval])
}
##### Step Function for q_hat #######
q_hat_func <- function(x, bins, q_hat){
interval <- cut(x, bins, include.lowest = T)
return(q_hat[interval])
}
##### Mixture distribution of Beta ######
dmixture <- function(x, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
f <- pi * dbeta(x, shape1 = shape_1 , shape2 = shape_2) + (1 - pi) * dbeta(x, shape1 = shape_3 , shape2 = shape_4)
return(f)
}
##### Random sample from Mixture Beta  #####
rmixture <- function(n, shape_1 = 2 , shape_2 = 15 , shape_3 = 12 , shape_4 = 6 , pi = 0.6 ){
sam <- c()
u <- runif(n)
for (x in u){
if (x < pi) sam <-c(sam, rbeta(1, shape1 = shape_1 , shape2 = shape_2))
else sam <- c(sam , rbeta(1, shape1 = shape_3 , shape2 = shape_4) )
}
return(sam)
}
#####  Simulation Function #######
simulation_function <- function(m , sim_size = 100, n=100, h = 1/m , eps = .1, func='beta'){
print(m)
if(func == 'beta'){
distr = function(x) dbeta(x,shape1 = 10, shape2 = 10)
sample_distr = function(n) rbeta(n, 10, 10)}
else if(func == 'mixture'){
distr = dmixture
sample_distr = function(n) rmixture(n)}
else{stop("The 'func' input is wrong. Choose between 'beta' or 'mixture'!")}
matr <- matrix(NA , )
matr_integral <- matrix(NA , nrow = sim_size  , ncol = 3)
for(rep in 1:sim_size){
bins <- seq(0, 1, h)    # Set the bins
intervals <- cut(sample_distr(n), bins, include.lowest = T)  # Rename units with the bins they belong
p_hat <- as.vector((table(intervals) / n)  / h)              # Computing high of each bin dividing the frequencies for the width of the bin
# Generating m values from a Laplacian: one for each bin
Dj <- table(intervals) + rlaplace(m, 0, 2/eps)               # Adding nu to every absolute frequencies of each bin
Dj[Dj < 0] = 0    # Set all the nagative values to 0 t
qj_hat = Dj
# Finding qj_hat dividing max(0, Dj) for the sum of Dj
if (sum(qj_hat) != 0){
qj_hat <- qj_hat / sum(qj_hat)} else {qj_hat <- rep(0, length(qj_hat))}
q_hat <- qj_hat / h      # Computing the high of the histogram dividing by the width of the columns
matr_integral[rep,1] <- integrate(function(x) ( distr(x) - p_hat_func(x,bins = bins , p_hat = p_hat))^2 , lower = 0 , upper = 1, subdivisions = 1200)$value
matr_integral[rep,2] <- integrate(function(x) (( distr(x) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2), lower = 0 , upper = 1, subdivisions = 1200)$value
matr_integral[rep,3] <- integrate(function(x) (( p_hat_func(x,bins = bins , p_hat = p_hat ) - q_hat_func(x,bins = bins , q_hat = q_hat ))^2), lower = 0 , upper = 1, subdivisions = 1200)$value
}
mise_p <- mean(matr_integral[,1])   #Save the results
mise_q <- mean(matr_integral[,2])   #Save the results
mise_pq <- mean(matr_integral[,3])
return(c(mise_p , mise_q, mise_pq))
}
##### Running Simulation  #####
m <- seq(5,50, 1)
simulation_size <- 100
labels <- c("p_hat" , "q_hat", 'pq')
#######Beta
### 1
Mixture_sim_n100_eps_01 <- lapply(m, simulation_function, sim_size = simulation_size, n=100 , func='mixture', eps = .1)
setwd("C:/Users/mcm23/OneDrive/Desktop/GitHub/SDS_HomeWork_3")
load("hw3_data.RData")
View(asd_data)
# Count how many patients in the ASD group have time series of a given length
sort( table( sapply(asd_data, function(x) nrow(x)) ), decreasing = T )
asd_data$caltech_0051472
dim(asd_data$caltech_0051472)
a <-  asd_data$caltech_0051472
a[[1]]
a <-  asd_data$caltech_005147[[1]]
plot(a)
plot(a, type='l')
par(mfrow=c(85, 116))
a <-  asd_data$caltech_005147
dim(a)
dim(a)[1]
plot(a, type='l')
plot(a[[1]], type='l')
plot(a[[1]], type='l')
a <-  asd_data[[1]]
a <-  asd_data[[1]][[1]]
dim(asd_data)
len(asd_data)
length(asd_data)
manipulate(plot(asd_data[[patient]][[region]]), patient = slider(1,length(asd_data)), region = slider(1,116))
library(manipulate)
manipulate(plot(asd_data[[patient]][[region]]), patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]]), patient = slider(1,length(asd_data)), region = slider(1,116))
par(mfrow=c(1, 1))
manipulate(plot(asd_data[[patient]][[region]]), patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]], type='l'), patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]], type='l', main = paste("patient:", patient, 'ROI:', region)),
patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]], type='l', main = paste("patient:", patient, '\nROI:', region)),
patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]], type='l', main = paste0("Patient-", patient, '\nROI-', region)),
patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]], type='l', main = paste0("Patient-", patient, '\nROI-', region), xlab = 'observations', ylab = 'value'),
patient = slider(1,length(asd_data)), region = slider(1,116))
manipulate(plot(td_data[[patient]][[region]], type='l', main = paste0("Patient-", patient, '\nROI-', region), xlab = 'observations', ylab = 'value'),
patient = slider(1,length(td_data)), region = slider(1,116))
manipulate(plot(asd_data[[patient]][[region]], type='l', main = paste0("Patient-", patient, '\nROI-', region), xlab = 'observations', ylab = 'value'),
patient = slider(1,length(asd_data)), region = slider(1,116))
plot_manipulate <- function(data){
manipulate(plot(data[[patient]][[region]], type='l', main = paste0("Patient-", patient, '\nROI-', region),
xlab = 'observations', ylab = 'value'),
patient = slider(1,length(data)), region = slider(1,116))
}
plot_manipulate(asd_data)
manipulate(plot(asd_data[[patient]][[region]], type='l', main = paste0("Patient-", patient, '\nROI-', region), xlab = 'observations', ylab = 'value'),
patient = slider(1,length(asd_data)), region = slider(1,116))
